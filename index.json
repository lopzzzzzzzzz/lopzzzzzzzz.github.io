[{"content":"JWT jwt，即json-web-token，是一种轻量级的认证的令牌，通常用于身份认证和授权。由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。\n头部（Header）：JWT 的头部包含了两部分信息：令牌类型（typ）和签名算法（alg），用 Base64 编码后的字符串表示。 载荷（Payload）：JWT 的载荷包含了一些声明（Claims），用来表示一些实体（主题、发行者、过期时间等）和一些元数据。需要注意的是，载荷中的信息是可以被解码的，因此不要在 JWT 中存储敏感信息。 签名（Signature）：JWT 的签名用于验证消息的完整性和真实性。签名的过程需要使用头部和载荷中的信息，以及一个秘钥，然后通过指定的算法进行签名。 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOjEzMzA4MDgxNTYyMDg1Mzc2MCwidXNlcm5hbWUiOiJ3d3ciLCJleHAiOjE2ODcwOTgxNzksImlzcyI6IndlYi1hcHAifQ.29KktS5R7sZt_K23CfAElgusmrHw8rbsp8ftKoVkWsc\n这是一个token，分为3段，每一段都被.隔开，前两段分别由头部和载荷Base64URL转化为字符串，由.连接起来，最后使用特定算法对前2段和一个特定的secret拼凑起来加密。\n1 HMACSHA256( base64UrlEncode(header) + \u0026#34;.\u0026#34; +base64UrlEncode(payload), secret) 如下图是上面token的一个解密。\n使用jwt完成登陆认证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 //token的生成与解析 package auth import ( \u0026#34;errors\u0026#34; \u0026#34;github.com/dgrijalva/jwt-go\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; \u0026#34;time\u0026#34; ) //结构体，也就是jwt中对应的payload，可以自定义 type MyClaim struct { Userid int64 `json:\u0026#34;userid\u0026#34;` Username string `json:\u0026#34;username\u0026#34;` jwt.StandardClaims } //secret var CustomSecret = []byte(\u0026#34;happy\u0026#34;) var InvalidToken = errors.New(\u0026#34;invalid token\u0026#34;) //生成token func GetToken(username string, userid int64) (string, error) { //根据配置文件获取token的过期时间 TokenExpireDuration := viper.GetInt64(\u0026#34;jwt.tokenExpire\u0026#34;) mc := \u0026amp;MyClaim{ Userid: userid, Username: username, StandardClaims: jwt.StandardClaims{ Issuer: \u0026#34;web-app\u0026#34;, //设置过期时间 ExpiresAt: time.Now().Add(time.Duration(TokenExpireDuration)).Unix(), }, } //使用HS256加密算法 token := jwt.NewWithClaims(jwt.SigningMethodHS256, mc) return token.SignedString(CustomSecret) } // 解析token func ParseToken(tokenString string) (*MyClaim, error) { mc := new(MyClaim) token, err := jwt.ParseWithClaims(tokenString, mc, func(token *jwt.Token) (interface{}, error) { return CustomSecret, nil }) if err != nil { return nil, err } if token.Valid { return mc, nil } return nil, InvalidToken } 完成jwt的生成解析后，就可以写中间件了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package middlewares import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;web_app/controller\u0026#34; \u0026#34;web_app/dao/redis\u0026#34; \u0026#34;web_app/utils/auth\u0026#34; ) var CtxUserIDKey = \u0026#34;userId\u0026#34; func JWTAuthMiddleware(c *gin.Context) { //从请求头拿出token，token不一定在这里，需要和前端协同 authHeader := c.Request.Header.Get(\u0026#34;Authorization\u0026#34;) if authHeader == \u0026#34;\u0026#34; { //自定义的返回方法 controller.ResponseError(c, controller.CodeNeedLogin) c.Abort() return } part := strings.SplitN(authHeader, \u0026#34; \u0026#34;, 2) if len(part) != 2 || part[0] != \u0026#34;Bearer\u0026#34; { controller.ResponseError(c, controller.CodeInvalidToken) c.Abort() return } mc, err := auth.ParseToken(part[1]) if err != nil { controller.ResponseError(c, controller.CodeInvalidToken) c.Abort() return } //每次请求都可以解析出user信息，可以辨别是哪个用户 c.Set(CtxUserIDKey, mc.Userid) c.Next() } 限制一个设备登陆 这里用的方案是使用redis+jwt，每次登陆完，将用户的username和token存到redis中，如果有新的登陆，将会覆盖原来的token。当用户在A端第一次登陆后，生成的token会存到redis中返回给用户，用户拿着这个token来访问特定的资源时，会和redis中的token进行比较，如果一致，才允许放行。而如果在用户在B端又进行了登陆，那么新的token将会覆盖旧的token，当用户在A端拿着旧的token来访问时，与redis中的token明显不一致，此时会拒绝访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package redis import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/go-redis/redis/v8\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;time\u0026#34; ) var NotExistToken = errors.New(\u0026#34;不存在的key\u0026#34;) //存redis func StorgeUserIdToken(token, username string) (err error) { ctx := context.Background() //同样获取token存活时间，将redis的token时间设为一致 duration := time.Duration(viper.GetInt(\u0026#34;jwt.tokenExpire\u0026#34;)) //存进redis if err = rdb.Set(ctx, username, token, duration).Err(); err != nil { zap.L().Error(\u0026#34;insert username into redis error\u0026#34;, zap.Error(err)) fmt.Printf(\u0026#34;insert username into redis error:%v\\n\u0026#34;, err) } return } //从redis取token func GetJwtToken(username string) (token string, err error) { ctx := context.Background() token, err = rdb.Get(ctx, username).Result() if err == redis.Nil { return \u0026#34;\u0026#34;, NotExistToken } if err != nil { zap.L().Error(\u0026#34;search redis error\u0026#34;, zap.Error(err)) return } return } 然后在刚刚的中间件加上以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //获取token token, err := redis.GetJwtToken(mc.Username) //如果token不存在，判定需要登陆 if err == redis.NotExistToken { controller.ResponseError(c, controller.CodeNeedLogin) c.Abort() return } //比较token，不一致则判定已在另一端登陆 if part[1] != token { controller.ResponseError(c, controller.CodelimitLogin) c.Abort() return } c.Set(CtxUserIDKey, mc.Userid) c.Next() 效果 登陆\n登陆成功后，复制刚刚的token去访问\n重新发起一个登陆请求\n仍是第一次登陆的token去访问\n","permalink":"https://lopzzzzzzzzz.github.io/posts/tech/jwt%E9%99%90%E5%88%B6%E4%B8%80%E4%B8%AA%E8%AE%BE%E5%A4%87%E7%99%BB%E9%99%86/","summary":"JWT jwt，即json-web-token，是一种轻量级的认证的令牌，通常用于身份认证和授权。由三部分组成：头部（Header）、载荷（Pay","title":"Go-Jwt登陆，以及限制一个设备登陆"},{"content":"脚手架有什么用 脚手架（Scaffold）是一种快速搭建项目的工具，可以帮助开发人员自动化生成项目的基础结构和文件，从而提高开发效率和减少出错的可能性。脚手架通常包含了项目的基本目录结构、配置文件、模板文件等，可以根据需要进行修改和定制。使用脚手架可以大大简化项目的搭建和配置过程，减少开发人员的工作量和出错的可能性。\n配置Viper viper 是 Go 应用程序的完整配置解决方案，它旨在在应用程序中工作，并且可以处理所有类型的配置需求和格式。\n安装viper：go get github.com/spf13/viper\n安装完之后，在项目目录下设置配置文件，这里使用的是yaml格式，创建config.yaml\n写入你需要的配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 app: name: \u0026#34;web_app\u0026#34; mode: \u0026#34;dev\u0026#34; port: 8081 log: level: \u0026#34;debug\u0026#34; filename: \u0026#34;web_app.log\u0026#34; max_size: 200 max_age: 30 max_backups: 7 mysql: host: \u0026#34;127.0.0.1\u0026#34; port: 3306 user: \u0026#34;root\u0026#34; password: \u0026#34;123456\u0026#34; dbname: \u0026#34;db_name\u0026#34; max_open_conns: 200 max_idle_conns: 50 redis: host: \u0026#34;\u0026#34; port: 6379 password: \u0026#34;\u0026#34; db: 0 pool_size: 100 在项目下创建config/config.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package config import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/fsnotify/fsnotify\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func Init() (err error) { viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) // 指定配置文件路径 err = viper.ReadInConfig() // 读取配置信息 if err != nil { fmt.Printf(\u0026#34;Read ConfigFile Error, err:%v\\n\u0026#34;, err) // 读取配置信息失败 return err } // 监控配置文件变化 viper.WatchConfig() viper.OnConfigChange(func(in fsnotify.Event) { fmt.Printf(\u0026#34;ConfigFile Changed:%v\\n\u0026#34;, in.Name) }) return } 配置日志log go自带的日志使用起来非常简单，但它缺少INFO/DEBUG/ERROR日志级别，不可以在正常情况下记录错误，只能panic或退出程序下记录，也不能提供日志切割。\n安装zap：go get -u go.uber.org/zap\n安装lumberjack：go get gopkg.in/natefinch/lumberjack.v2\n创建logger/logger.go(以下代码参考自)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 package logger import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/natefinch/lumberjack\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;go.uber.org/zap/zapcore\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/http/httputil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;runtime/debug\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) var lg *zap.Logger // InitLogger 初始化Logger func Init() (err error) { writeSyncer := getLogWriter(viper.GetString(\u0026#34;log.filename\u0026#34;), viper.GetInt(\u0026#34;log.max_size\u0026#34;), viper.GetInt(\u0026#34;log.max_backups\u0026#34;), viper.GetInt(\u0026#34;log.max_age\u0026#34;)) encoder := getEncoder() var l = new(zapcore.Level) err = l.UnmarshalText([]byte(viper.GetString(\u0026#34;log.level\u0026#34;))) if err != nil { return } core := zapcore.NewCore(encoder, writeSyncer, l) lg = zap.New(core, zap.AddCaller()) zap.ReplaceGlobals(lg) // 替换zap包中全局的logger实例，后续在其他包中只需使用zap.L()调用即可 return } func getEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.TimeKey = \u0026#34;time\u0026#34; encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder encoderConfig.EncodeDuration = zapcore.SecondsDurationEncoder encoderConfig.EncodeCaller = zapcore.ShortCallerEncoder return zapcore.NewJSONEncoder(encoderConfig) } func getLogWriter(filename string, maxSize, maxBackup, maxAge int) zapcore.WriteSyncer { lumberJackLogger := \u0026amp;lumberjack.Logger{ Filename: filename, MaxSize: maxSize, MaxBackups: maxBackup, MaxAge: maxAge, } return zapcore.AddSync(lumberJackLogger) } // GinLogger 接收gin框架默认的日志 func GinLogger() gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() path := c.Request.URL.Path query := c.Request.URL.RawQuery c.Next() cost := time.Since(start) lg.Info(path, zap.Int(\u0026#34;status\u0026#34;, c.Writer.Status()), zap.String(\u0026#34;method\u0026#34;, c.Request.Method), zap.String(\u0026#34;path\u0026#34;, path), zap.String(\u0026#34;query\u0026#34;, query), zap.String(\u0026#34;ip\u0026#34;, c.ClientIP()), zap.String(\u0026#34;user-agent\u0026#34;, c.Request.UserAgent()), zap.String(\u0026#34;errors\u0026#34;, c.Errors.ByType(gin.ErrorTypePrivate).String()), zap.Duration(\u0026#34;cost\u0026#34;, cost), ) } } // GinRecovery recover掉项目可能出现的panic，并使用zap记录相关日志 func GinRecovery(stack bool) gin.HandlerFunc { return func(c *gin.Context) { defer func() { if err := recover(); err != nil { // Check for a broken connection, as it is not really a // condition that warrants a panic stack trace. var brokenPipe bool if ne, ok := err.(*net.OpError); ok { if se, ok := ne.Err.(*os.SyscallError); ok { if strings.Contains(strings.ToLower(se.Error()), \u0026#34;broken pipe\u0026#34;) || strings.Contains(strings.ToLower(se.Error()), \u0026#34;connection reset by peer\u0026#34;) { brokenPipe = true } } } httpRequest, _ := httputil.DumpRequest(c.Request, false) if brokenPipe { lg.Error(c.Request.URL.Path, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), ) // If the connection is dead, we can\u0026#39;t write a status to it. c.Error(err.(error)) // nolint: errcheck c.Abort() return } if stack { lg.Error(\u0026#34;[Recovery from panic]\u0026#34;, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), zap.String(\u0026#34;stack\u0026#34;, string(debug.Stack())), ) } else { lg.Error(\u0026#34;[Recovery from panic]\u0026#34;, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), ) } c.AbortWithStatus(http.StatusInternalServerError) } }() c.Next() } } 连接mysql 创建dao/mysql/mysql.go\n安装驱动：go get -u github.com/go-sql-driver/mysql\n安装sqlx： go get github.com/jmoiron/sqlx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package mysql import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/jmoiron/sqlx\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var db *sqlx.DB func Init() (err error) { dsn := fmt.Sprintf(\u0026#34;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4\u0026amp;parseTime=True\u0026#34;, viper.GetString(\u0026#34;mysql.user\u0026#34;), viper.GetString(\u0026#34;mysql.password\u0026#34;), viper.GetString(\u0026#34;mysql.host\u0026#34;), viper.GetInt(\u0026#34;mysql.port\u0026#34;), viper.GetString(\u0026#34;dbname\u0026#34;)) db, err = sqlx.Connect(\u0026#34;mysql\u0026#34;, dsn) if err != nil { zap.L().Error(\u0026#34;Init Mysql Error\u0026#34;, zap.Error(err)) return } db.SetMaxOpenConns(viper.GetInt(\u0026#34;max_open_conns\u0026#34;)) db.SetMaxIdleConns(viper.GetInt(\u0026#34;max_idle_conns\u0026#34;)) return } func Close() { db.Close() } 连接redis 在项目目录下创建dao/redis/redis.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package redis import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/go-redis/redis/v8\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) var rdb *redis.Client func Init() (err error) { rdb = redis.NewClient(\u0026amp;redis.Options{ Addr: fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, viper.GetString(\u0026#34;redis.host\u0026#34;), viper.GetInt(\u0026#34;redis.port\u0026#34;)), Password: viper.GetString(\u0026#34;redis.password\u0026#34;), PoolSize: viper.GetInt(\u0026#34;redis.pool_size\u0026#34;), DB: viper.GetInt(\u0026#34;redis.db\u0026#34;), }) _, err = rdb.Ping(context.Background()).Result() return } func Close() { rdb.Close() } 配置路由 创建routes/routes.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package routes import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;web_app/logger\u0026#34; ) func Setup() *gin.Engine { r := gin.New() r.Use(logger.GinLogger(), logger.GinRecovery(true)) r.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { c.String(http.StatusOK, \u0026#34;ok\u0026#34;) }) return r } 配置主程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; \u0026#34;web_app/config\u0026#34; \u0026#34;web_app/dao/mysql\u0026#34; \u0026#34;web_app/dao/redis\u0026#34; \u0026#34;web_app/logger\u0026#34; \u0026#34;web_app/routes\u0026#34; ) func main() { //初始化配置 if err := config.Init(); err != nil { fmt.Printf(\u0026#34;Init Config Error,err:%v\\n\u0026#34;, err) return } //初始化日志 if err := logger.Init(); err != nil { fmt.Printf(\u0026#34;Init Logger Error, err:%v\\n\u0026#34;, err) return } defer zap.L().Sync() //初始化sql if err := mysql.Init(); err != nil { fmt.Printf(\u0026#34;Init Mysql Error, err:%v\\n\u0026#34;, err) return } defer mysql.Close() //初始化redis if err := redis.Init(); err != nil { fmt.Printf(\u0026#34;Init Redis Error, err:%v\\n\u0026#34;, err) return } defer redis.Close() r := routes.Setup() srv := \u0026amp;http.Server{ Addr: fmt.Sprintf(\u0026#34;:%d\u0026#34;, viper.GetInt(\u0026#34;app.port\u0026#34;)), Handler: r, } go func() { if err := srv.ListenAndServe(); err != nil \u0026amp;\u0026amp; err != http.ErrServerClosed { zap.L().Fatal(\u0026#34;listen err\u0026#34;, zap.Error(err)) } }() quit := make(chan os.Signal, 1) // kill 默认会发送 syscall.SIGTERM 信号 // kill -2 发送 syscall.SIGINT 信号，我们常用的Ctrl+C就是触发系统SIGINT信号 // kill -9 发送 syscall.SIGKILL 信号，但是不能被捕获，所以不需要添加它 // signal.Notify把收到的 syscall.SIGINT或syscall.SIGTERM 信号转发给quit signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) \u0026lt;-quit // 阻塞在此，当接收到上述两种信号时才会往下执行 zap.L().Info(\u0026#34;shutdown server\u0026#34;) ctx, cancelFunc := context.WithTimeout(context.Background(), time.Second*5) defer cancelFunc() // 5秒内优雅关闭服务（将未处理完的请求处理完再关闭服务），超过5秒就超时退出 if err := srv.Shutdown(ctx); err != nil { zap.L().Fatal(\u0026#34;Server Shutdown:\u0026#34;, zap.Error(err)) } zap.L().Info(\u0026#34;Server exiting\u0026#34;) } 到此，脚手架就全部搭建完成，启动后，访问localhost:8081，收到返回的ok，说明搭建成功了。\n","permalink":"https://lopzzzzzzzzz.github.io/posts/tech/go%E8%84%9A%E6%89%8B%E6%9E%B6/","summary":"脚手架有什么用 脚手架（Scaffold）是一种快速搭建项目的工具，可以帮助开发人员自动化生成项目的基础结构和文件，从而提高开发效率和减少出错","title":"Go脚手架学习"},{"content":"安装驱动 go中database/sql已封装好了完整的sql使用API，但没有驱动，需要导入对应数据库的驱动。\n在这里以mysql为例，Go MySQL Driver是 Godatabase/sql/driver接口的一个实现，只需导入驱动程序即可。\n在项目demo终端下载驱动：\ngo get -u github.com/go-sql-driver/mysql\n连接数据库 原生包中func Open(driverName, dataSourceName string ) (* DB , error )函数打开数据库，返回一个DB对象，DB 是一个数据库句柄，表示一个包含零个或多个底层连接的池。多个 goroutine 并发使用它是安全的。。\n其中dervierName指定数据库名称，dataSourceName为数据源名称（DSN）。\nDSN其格式为username:password@protocol(address)/dbname?param=value，其中dbname为要连接的库名字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) //创建全局db对象 var db *sql.DB func initDB() (err error) { dsn := \u0026#34;root:123456@tcp(127.0.0.1:3306)/sys?charset=utf8mb4\u0026amp;parseTime=True\u0026#34; db, err = sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { panic(err) } //ping为测试是否连通，确保真正连接上 err = db.Ping() if err != nil { fmt.Printf(\u0026#34;connect failed,err:%v\u0026#34;, err) return } return } func main() { err := initDB() if err != nil { fmt.Printf(\u0026#34;init db failed,err:%v\\n\u0026#34;, err) return } defer db.Close() } 基本使用 通过创建user表，同以下结构，进行CRUD\n创建user结构体\n1 2 3 4 5 type user struct { id int name string age int } Query 查询一行 func (db * DB ) QueryRow(query string , args ... any ) * Row\nQueryRow 执行最多返回一行的查询。QueryRow 总是返回一个非零值。错误会延迟到调用 Row 的 Scan 方法时出现。\n1 2 3 4 5 6 7 8 9 10 11 func queryRow() { var u1 user queryStr := \u0026#34;select * from user where id = ?\u0026#34; row := db.QueryRow(queryStr, 1) err := row.Scan(\u0026amp;u1.id, \u0026amp;u1.name, \u0026amp;u1.age) if err != nil { fmt.Printf(\u0026#34;queryRow error: %v\u0026#34;, err) return } fmt.Println(u1) } 查询多行 func (db * DB ) Query(query string , args ... any ) (* Rows , error )\nQuery 执行返回多行的查询\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func query() { userSlice := make([]user, 0, 2) rows, _ := db.Query(\u0026#34;select * from user\u0026#34;) defer rows.Close() //在这里调用close是因为不确定scan时是否会出错，如出错，而rows又会一直占用连接，此时应该关闭 for rows.Next() { var u user err := rows.Scan(\u0026amp;u.id, \u0026amp;u.name, \u0026amp;u.age) if err != nil { fmt.Printf(\u0026#34;query error: %v\u0026#34;, err) continue } userSlice = append(userSlice, u) } fmt.Println(userSlice) } Exec Exec 执行查询而不返回任何行，插入、更新和删除操作都使用它。\nExec返回一个Result实例\n1 2 3 4 5 6 type Result interface { // LastInsertId 返回数据库生成的整数,即为自增的id。并非所有数据库都支持此功能，并且此类语句的语法各不相同 LastInsertId() ( int64 , error ) // RowsAffected 返回受 更新、插入或删除影响的行数。并非每个数据库或数据库驱动程序都支持这一点。 RowsAffected() ( int64 ,错误) }\t插入 1 2 3 4 5 6 7 8 9 10 11 func execInsert() { insertSql := \u0026#34;insert into user(name,age) values(?,?)\u0026#34; insertRes, err := db.Exec(insertSql, \u0026#34;汪汪汪汪\u0026#34;, 24) if err != nil { fmt.Printf(\u0026#34;insert failed, err:%v\u0026#34;, err) return } insertId, _ := insertRes.LastInsertId() //最后插入的id rowsAffected, _ := insertRes.RowsAffected() //影响的行数 fmt.Println(insertId, rowsAffected) } 更新 1 2 3 4 5 6 7 8 9 10 func execUpdate() { updateSql := \u0026#34;update user set age = ? where id = ?\u0026#34; res, err := db.Exec(updateSql, 18, 3) if err != nil { fmt.Printf(\u0026#34;update failed, err:%v\u0026#34;, err) return } rowsAffected, _ := res.RowsAffected() fmt.Println(rowsAffected) } 删除 1 2 3 4 5 6 7 8 9 10 func execDelete() { delectSql := \u0026#34;delete from user where id = ?\u0026#34; res, err := db.Exec(delectSql, 1) if err != nil { fmt.Printf(\u0026#34;delete failed, err:%v\u0026#34;, err) return } rowsAffected, _ := res.RowsAffected() fmt.Println(rowsAffected) } 预处理 在以上这些CRUD中，使用的都是即时SQL，数据库接收到一条sql后，其执行流程大致如下：\n​\t1.词法和语义解析\n​\t2.优化 SQL 语句，制定执行计划\n​\t3.执行并返回结果\n一次编译，一次运行，而大部分情况下，一条sql其实是一直被反复运行的，如单纯的查询操作，又或者是sql中的参数不同，其他都一样，如果每次都要经历这样的流程去解析，无疑会降低效率。\n预处理通过将一般sql语句模版化，做到一次编译，多次运行，提高效率。\n使用下面函数来进行预处理\nfunc (db * DB ) Prepare(query string ) (* Stmt , error )\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func prepare() { stmt, err := db.Prepare(\u0026#34;select * from user where id = ?\u0026#34;) if err != nil { fmt.Printf(\u0026#34;exec Prepare failed, err:%v\u0026#34;, err) return } var u user err = stmt.QueryRow(4).Scan(\u0026amp;u.id, \u0026amp;u.name, \u0026amp;u.age) if err != nil { fmt.Printf(\u0026#34;queryRow err:%v\u0026#34;, err) return } fmt.Println(u) } 其他的操作也大同小异。\n事务 在sql包中，有3个关于事务的主要方法。\nfunc (db *DB) Begin() (*Tx, error)：开启事务\nfunc (tx *Tx) Commit() error：提交事务\nfunc (tx *Tx) Rollback() error：回滚事务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func tx() { tx, err := db.Begin() if err != nil { fmt.Printf(\u0026#34;tx begin error : %v\u0026#34;, err) return } updateSql := \u0026#34;update user set age = ? where id = ?\u0026#34; _, err = tx.Exec(updateSql, 38, 2) if err != nil { fmt.Printf(\u0026#34;error:%v\u0026#34;, err) tx.Rollback() return } _, err = tx.Exec(updateSql, 29, 4) if err != nil { fmt.Printf(\u0026#34;error:%v\u0026#34;, err) tx.Rollback() return } tx.Commit() fmt.Println(\u0026#34;ok\u0026#34;) } 加入预处理的事务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func txPrepare() { tx, err := db.Begin() if err != nil { fmt.Printf(\u0026#34;tx begin error : %v\u0026#34;, err) return } stmt, _ := tx.Prepare(\u0026#34;update user set age = ? where id = ?\u0026#34;) _, err = stmt.Exec(28, 2) if err != nil { fmt.Printf(\u0026#34;error:%v\u0026#34;, err) tx.Rollback() return } _, err = stmt.Exec(22, 4) if err != nil { fmt.Printf(\u0026#34;error:%v\u0026#34;, err) tx.Rollback() return } tx.Commit() fmt.Println(\u0026#34;ok\u0026#34;) } ","permalink":"https://lopzzzzzzzzz.github.io/posts/tech/go%E5%8E%9F%E7%94%9Fsql%E4%BD%BF%E7%94%A8/","summary":"安装驱动 go中database/sql已封装好了完整的sql使用API，但没有驱动，需要导入对应数据库的驱动。 在这里以mysql为例，Go MySQL","title":"Go原生sql使用"},{"content":"安装Hugo 我使用的是macos系统，用homebrew进行安装，也可以去github上安装。\n1 brew install hugo 安装完后在终端输入查看版本确认是否安装成功。\n1 hugo version 我的显示如下：\n安装完后找一个你博客想存放的目录，就可以建站了。\n1 hugo new site myblog 导入主题，hugo有很多主题，挑选一个你喜欢的，在文件内git下来就可以了，这里我使用的PaperMod\n1 2 cd myblog #先进入文件内 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 #导入主题 在myblog内找到config.toml配置文件，打开来，加上theme = \u0026ldquo;PaperMod\u0026rdquo;，打开终端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #输入： hugo server #输出： Start building sites … hugo v0.108.0+extended darwin/arm64 BuildDate=unknown | EN -------------------+----- Pages | 26 Paginator pages | 0 Non-page files | 0 Static files | 6 Processed images | 0 Aliases | 5 Sitemaps | 1 Cleaned | 0 Built in 48 ms Watching for changes in /Users/zzzlin/Documents/myblog/{archetypes,assets,content,data,layouts,static,themes} Watching for config changes in /Users/zzzlin/Documents/myblog/config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 输入完，在浏览器输入 http://localhost:1313/ 便可以进入博客，目前并没有创建什么笔记，所以里面内容都是为空的。\n部署到github Pages ​\t在github创建仓库，仓库名字一定是 .github.io , 这里的填的是你github账号名字（包括括号），一定要对应的上，否则为出错。\n​\t创建完后，在myblog目录下，修改config.toml，将baseURL = \u0026ldquo;https://.github.io/\u0026quot;，这样后续的资源文章都会以这个路径寻找，保存完，终端输入hugo，执行完毕后，会生成public文件夹，里面的文件我们将部署到github。\n1 2 3 4 5 6 cd public git init git remote add origin git@github.com:\u0026lt;\u0026gt;/\u0026lt;\u0026gt;.github.io.git #这里要换成你的仓库地址 git add . git commit -m \u0026#39;first commit\u0026#39; git push 做完这些，public文件下的东西都会上传到仓库里，在仓库settings中找到pages，将source设置为 Deploy from a branch，不出意外，过一会就会自动部署上去了。 修改配置\n修改config.toml配置，和创建文章的配置，推荐按[置顶] hugo博客搭建 | PaperMod主题进行配置。\n创建笔记 还是回到终端myblog路径下，输入hugo new ****.md, 创建名为****的markdown格式的笔记，所有的笔记都会在content目录下，根据你的需要在conteng下创建文件夹进行分类，比如我这里的是分类是技术、生活，就创建了content/post/tech/和content/post/life。\n创建完后，在笔记最上方有进行配置的设置，draft: true # 是否为草稿，设置为true时，默认不会显示，可以输入hugo server -D便可在本地查看，写完后应改为false。\n发布新写完的笔记 当你想发布一篇新的笔记或修改了配置，同样的，在myblog目录下，输入hugo ，更新public文件夹\n1 2 3 4 cd public git add . git commit -m \u0026#39;注释，如发布**笔记\u0026#39; git push push完后过一会就可以在github站点看到你的内容更新了。\n","permalink":"https://lopzzzzzzzzz.github.io/posts/life/hugo%E5%BB%BA%E7%AB%99/","summary":"安装Hugo 我使用的是macos系统，用homebrew进行安装，也可以去github上安装。 1 brew install hugo 安装完后在终端输入查看版本确认是否安装","title":"Hugo建站并部署github pages"},{"content":"1. defer的执行顺序类似于栈，“后进先出”，也就是最先defer的语句最后执行，而最后defer的最先执行 1 2 3 4 5 6 7 8 9 10 func main() { defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) } //控制台打印 3 2 1 2. defer和return的坑 首先return操作并不是原子操作，他分为2步：一是给返回值赋值，二是return返回值。如果函数中有defer的话，那么defer会被夹杂在2步中间，也就是先给返回值赋值，执行defer，return返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func main() { fmt.Println(\u0026#34;匿名返回：\u0026#34;, a()) //5 fmt.Println(\u0026#34;有名返回：\u0026#34;, b()) //6 } // 匿名返回值 func a() int { x := 5 defer func() { x++ }() return x } // 有名返回值 func b() (x int) { x = 5 defer func() { x++ }() return x } 使用匿名返回函数，控制台打印的是5，这是执行return x时，首先定义 返回值=x（非同一个变量），然后执行defer x++，最后return返回值，而此时返回值已经=x，x++不会再影响返回值了，所以返回的是5。\n使用有名返回时，就指定了返回值=x（同一个变量，内存地址相同），所以x++后，返回的值也++了。\n3. defer注册要延迟执行的函数时该函数所有的参数都需要确定其值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } func main() { x := 1 y := 2 defer calc(\u0026#34;AA\u0026#34;, x, calc(\u0026#34;A\u0026#34;, x, y)) x = 10 defer calc(\u0026#34;BB\u0026#34;, x, calc(\u0026#34;B\u0026#34;, x, y)) y = 20 } 第一次注册defer calc(\u0026ldquo;AA\u0026rdquo;, x, calc(\u0026ldquo;A\u0026rdquo;, x, y))时，会执行里面的calc(\u0026ldquo;A\u0026rdquo;, x, y)，此时x=1，y=2，所以先打印，\n1 A 1 2 3 于是defer calc(\u0026ldquo;AA\u0026rdquo;, x, calc(\u0026ldquo;A\u0026rdquo;, x, y))中的参数被确定，是defer calc(\u0026ldquo;AA\u0026rdquo;, 1, 3)\n接下来x=10，y没变，仍等于2，执行defer calc(\u0026ldquo;BB\u0026rdquo;, x, calc(\u0026ldquo;B\u0026rdquo;, x, y))，执行calc(\u0026ldquo;B\u0026rdquo;, x, y)，打印\n1 B 10 2 12 于是defer calc(\u0026ldquo;BB\u0026rdquo;, x, calc(\u0026ldquo;B\u0026rdquo;, x, y))中的参数被确定，是defer calc(\u0026ldquo;BB\u0026rdquo;, 10, 12)\n然后按照defer顺序执行，先执行defer calc(\u0026ldquo;BB\u0026rdquo;, 10, 12)，再执行defer calc(\u0026ldquo;AA\u0026rdquo;, 1, 3)，所以打印\n1 2 BB 10 12 22 AA 1 3 4 ","permalink":"https://lopzzzzzzzzz.github.io/posts/tech/go%E4%B8%ADdefer%E4%BD%BF%E7%94%A8/","summary":"1. defer的执行顺序类似于栈，“后进先出”，也就是最先defer的语句最后执行，而最后defer的最先执行 1 2 3 4 5 6 7 8 9 10 func main() { defer fmt.Println(\u0026#34;1\u0026#34;) defer","title":"Go中Defer使用"},{"content":"在使用for循环修改结构体切片中的值时，发现并没有修改成功。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type Dog struct { name string } func (d *Dog) setNewName(name string) { d.name = name } func main() { d := Dog{ name: \u0026#34;123\u0026#34;, } d1 := Dog{ name: \u0026#34;456\u0026#34;, } d2 := Dog{ name: \u0026#34;789\u0026#34;, } dogSlice := make([]Dog, 0) dogSlice = append(dogSlice, d, d1, d2) for _, dog := range dogSlice { dog.setNewName(\u0026#34;123\u0026#34;) } for _, dog := range dogSlice { fmt.Println(dog) } } 结果切片中dog的name并没有全部变为123，后来查资料才知道for循环中的dog其实是个变量，指向的并不是真正的dog。\n打印其地址对比可以看出压根就不同。\n1 2 3 4 5 6 7 for i, dog := range dogSlice { fmt.Printf(\u0026#34;dog地址：%p 切片中dog的真正地址：%p\\n\u0026#34;, \u0026amp;dog, \u0026amp;(dogSlice[i])) } dog地址：0x14000010230 切片中dog的真正地址：0x14000066180 dog地址：0x14000010230 切片中dog的真正地址：0x14000066190 dog地址：0x14000010230 切片中dog的真正地址：0x140000661a0 若要修改切片中的dog的name，应该按照以下这么写，或者将dogSlice变为存dog指针的切片，*dogSlice := make([]Dog, 0)\n1 2 3 4 5 6 7 8 9 10 11 for i, _ := range dogSlice { dogSlice[i].setNewName(\u0026#34;123\u0026#34;) } for _, v := range dogSlice { fmt.Println(v) } 打印如下： {123} {123} {123} ","permalink":"https://lopzzzzzzzzz.github.io/posts/tech/go%E4%B8%ADfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9D%91/","summary":"在使用for循环修改结构体切片中的值时，发现并没有修改成功。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type Dog struct { name string } func (d *Dog) setNewName(name string) {","title":"Go中for循环的坑"},{"content":"golang菜鸟，华农计算机硕士在读。\n","permalink":"https://lopzzzzzzzzz.github.io/about/","summary":"golang菜鸟，华农计算机硕士在读。","title":"About Me"}]