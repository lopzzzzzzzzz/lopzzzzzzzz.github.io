[{"content":"1. defer的执行顺序类似于栈，“后进先出”，也就是最先defer的语句最后执行，而最后defer的最先执行 1 2 3 4 5 6 7 8 9 10 func main() { defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) } //控制台打印 3 2 1 2. defer和return的坑 首先return操作并不是原子操作，他分为2步：一是给返回值赋值，二是return返回值。如果函数中有defer的话，那么defer会被夹杂在2步中间，也就是先给返回值赋值，执行defer，return返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func main() { fmt.Println(\u0026#34;匿名返回：\u0026#34;, a()) //5 fmt.Println(\u0026#34;有名返回：\u0026#34;, b()) //6 } // 匿名返回值 func a() int { x := 5 defer func() { x++ }() return x } // 有名返回值 func b() (x int) { x = 5 defer func() { x++ }() return x } 使用匿名返回函数，控制台打印的是5，这是执行return x时，首先定义 返回值=x（非同一个变量），然后执行defer x++，最后return返回值，而此时返回值已经=x，x++不会再影响返回值了，所以返回的是5。\n使用有名返回时，就指定了返回值=x（同一个变量，内存地址相同），所以x++后，返回的值也++了。\n3. defer注册要延迟执行的函数时该函数所有的参数都需要确定其值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } func main() { x := 1 y := 2 defer calc(\u0026#34;AA\u0026#34;, x, calc(\u0026#34;A\u0026#34;, x, y)) x = 10 defer calc(\u0026#34;BB\u0026#34;, x, calc(\u0026#34;B\u0026#34;, x, y)) y = 20 } 第一次注册defer calc(\u0026ldquo;AA\u0026rdquo;, x, calc(\u0026ldquo;A\u0026rdquo;, x, y))时，会执行里面的calc(\u0026ldquo;A\u0026rdquo;, x, y)，此时x=1，y=2，所以先打印，\n1 A 1 2 3 于是defer calc(\u0026ldquo;AA\u0026rdquo;, x, calc(\u0026ldquo;A\u0026rdquo;, x, y))中的参数被确定，是defer calc(\u0026ldquo;AA\u0026rdquo;, 1, 3)\n接下来x=10，y没变，仍等于2，执行defer calc(\u0026ldquo;BB\u0026rdquo;, x, calc(\u0026ldquo;B\u0026rdquo;, x, y))，执行calc(\u0026ldquo;B\u0026rdquo;, x, y)，打印\n1 B 10 2 12 于是defer calc(\u0026ldquo;BB\u0026rdquo;, x, calc(\u0026ldquo;B\u0026rdquo;, x, y))中的参数被确定，是defer calc(\u0026ldquo;BB\u0026rdquo;, 10, 12)\n然后按照defer顺序执行，先执行defer calc(\u0026ldquo;BB\u0026rdquo;, 10, 12)，再执行defer calc(\u0026ldquo;AA\u0026rdquo;, 1, 3)，所以打印\n1 2 BB 10 12 22 AA 1 3 4 ","permalink":"https://lopzzzzzzzzz.github.io/posts/tech/go%E4%B8%ADdefer%E4%BD%BF%E7%94%A8/","summary":"1. defer的执行顺序类似于栈，“后进先出”，也就是最先defer的语句最后执行，而最后defer的最先执行 1 2 3 4 5 6 7 8 9 10 func main() { defer fmt.Println(\u0026#34;1\u0026#34;) defer","title":"Go中Defer使用"},{"content":"在使用for循环修改结构体切片中的值时，发现并没有修改成功。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type Dog struct { name string } func (d *Dog) setNewName(name string) { d.name = name } func main() { d := Dog{ name: \u0026#34;123\u0026#34;, } d1 := Dog{ name: \u0026#34;456\u0026#34;, } d2 := Dog{ name: \u0026#34;789\u0026#34;, } dogSlice := make([]Dog, 0) dogSlice = append(dogSlice, d, d1, d2) for _, dog := range dogSlice { dog.setNewName(\u0026#34;123\u0026#34;) } for _, dog := range dogSlice { fmt.Println(dog) } } 结果切片中dog的name并没有全部变为123，后来查资料才知道for循环中的dog其实是个变量，指向的并不是真正的dog。\n打印其地址对比可以看出压根就不同。\n1 2 3 4 5 6 7 for i, dog := range dogSlice { fmt.Printf(\u0026#34;dog地址：%p 切片中dog的真正地址：%p\\n\u0026#34;, \u0026amp;dog, \u0026amp;(dogSlice[i])) } dog地址：0x14000010230 切片中dog的真正地址：0x14000066180 dog地址：0x14000010230 切片中dog的真正地址：0x14000066190 dog地址：0x14000010230 切片中dog的真正地址：0x140000661a0 若要修改切片中的dog的name，应该按照以下这么写，或者将dogSlice变为存dog指针的切片，*dogSlice := make([]Dog, 0)\n1 2 3 4 5 6 7 8 9 10 11 for i, _ := range dogSlice { dogSlice[i].setNewName(\u0026#34;123\u0026#34;) } for _, v := range dogSlice { fmt.Println(v) } 打印如下： {123} {123} {123} ","permalink":"https://lopzzzzzzzzz.github.io/posts/tech/go%E4%B8%ADfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9D%91/","summary":"在使用for循环修改结构体切片中的值时，发现并没有修改成功。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 type Dog struct { name string } func (d *Dog) setNewName(name string) {","title":"Go中for循环的坑"},{"content":"golang菜鸟，华农计算机硕士在读。\n","permalink":"https://lopzzzzzzzzz.github.io/about/","summary":"golang菜鸟，华农计算机硕士在读。","title":"About Me"}]